#아이디어
#2차원 dp 갱신 
#갈래 모으기 유형
#모든 경우의 수를 실행,최솟값 dp갱신

#i번째 집에 칠하는 경우는 r,g,b 3개이고 같은 색은 연속으로 쓸 수 없다
#i번째 r이라면 i-1에서 g,b를 칠하는 경우 중 비용이 작은 걸 고른다
#그렇게 i번째 r,g,b 각각을 수행하여 dp를 갱신한다
#즉 i번째의 r,g,b의 선택하는 경우 각각에 대한 최소를 만들고 i+1에서 그걸 사용한다
#i번째를 고를 때 i-1과만 다른 색을 고르면 되므로 그 이전은 상관없기 때문이다
#마지막에 dp[n-1] 중 최소를 고르면 정답이다

n=int(input())

#dp 테이블 초기화
dp=[]
for i in range(n):
  dp.append(list(map(int,input().split())))

#2차원 dp 갱신,모든 경우 수행
for i in range(1,n):
  #현재 가능한 r,g,b의 최솟값을 각각 갱신
  dp[i][0]+=min(dp[i-1][1],dp[i-1][2])
  dp[i][1]+=min(dp[i-1][0],dp[i-1][2])
  dp[i][2]+=min(dp[i-1][0],dp[i-1][1])

print(min(dp[n-1]))